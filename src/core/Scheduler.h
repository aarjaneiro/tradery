/*
   Copyright (C) 2018-2020 Adrian Michel

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#pragma once

#include "structuredexception.h"
#include "moremiscwin.h"
#include <log.h>

#include <atomic>
#include <chrono>
#include <future>
#include <mutex>

using namespace std::chrono_literals;

using EE = ErrorEvent::Types;

#define ERROR_EVENT_MESSAGE_SYMBOL( event, message, symbol ) addErrorEvent(std::make_shared< ErrorEvent >(EE::event, ErrorEvent::Category::error, getRunnableName(), message, symbol))
#define ERROR_EVENT_MESSAGE( event, message ) ERROR_EVENT_MESSAGE_SYMBOL( event, message, si->symbol().symbol() )
#define ERROR_EVENT( event ) ERROR_EVENT_MESSAGE( event, e.message() )

#define ERROR_EVENT_HANDLER( excp, event )  \
  catch (const excp& e) { \
    ERROR_EVENT(event); \
  }


/** @file
 *  \brief Contains all scheduler related classes
 */
extern DataManager* _dataManager;

/**
 * This class contains all the information needed to run a Runnable:
 * - the runnable itself
 * - an iterator pointing to the symbol in list of symbols on which to run the
 * Runnable
 * - the default positions container where the generated positions will be
 * stored
 * - the error sink object, where run time error events will be sent
 * - slippage and commission algorithms
 * - an signal handler, which will receive signals generated during the run (if
 * any)
 *
 * In order to run a Runnable, the Scheduler creates a thread (or reuses an
 * existing one) and calls the method RunnableInfo::run which intializes the
 * Runnable with the necessary information, starts its execution and calls the
 * cleanup methods when the execution is over. It also captures the runtime
 * errors triggered by the runnable, which are then sent to the ErrorSink.
 */
class RunnableInfo {
  OBJ_COUNTER(RunnableInfo)
 private:
  /**
   * the runnable.
   * TODO: Note that there is one instance, so when running multiple threads, we
   * won't be able to run the same runnable on multiple symbols at the same time
   * - fix this
   */
  Runnable* _runnable;

  /**
   * The list of symbols on which the runnable should be run
   */
  DataInfoIteratorPtr _symbols;
  /**
   * The list of cumulated positions generated by this runnable on all the
   * symbols
   */
  PositionsVector& _pos;
  size_t _crtSymbol;
  ErrorEventSink* _es;
  Slippage* _slippage;
  Commission* _commission;
  std::vector<SignalHandler*> _signalHandlers;
  RunnableRunInfoHandler* _runnableRunInfoHandler;
  chart::ChartManager* _chartManager;

  const ExplicitTrades* _explicitTrades;

 private:
  void addErrorEvent(ErrorEventPtr e) { _es->push(e); }

  /**
   *
   * @return
   */
  const std::string& getRunnableName() const { return _runnable->name(); }

 public:
  /**
   * Constructor - takes all the info needed by the Runnable to run as arguments
   *
   * @param runnable   pointer to a Runnable
   * @param symbols    Iterator on a list of symbols, pointing to the current
   * symbol to run the runnable on
   * @param pos        A collection of positions where to store the positions
   * generated during back-test run
   * @param es         An error sink, which will receive run time errors
   * triggered by the Runnable
   * @param slippage   Slippage algorithm
   * @param commission Commission algorithm
   * @param signalHandler
   *                   signal handler which will receive the signals generated
   * by the runnable (if any) during the run.
   * @param printStatus
   * @see PositionsPtrList
   * @see ErrorEventSink
   * @see Slippage
   * @see Commission
   * @see AlertHandler
   */
  RunnableInfo(Runnable* runnable, DataInfoIteratorPtr symbols, PositionsVector& pos, ErrorEventSink* es,
               SignalHandler* signalHandler, RunnableRunInfoHandler* runnableRunInfoHandler,
               Slippage* slippage, Commission* commission, chart::ChartManager* chartManager,
               const ExplicitTrades* explicitTrades)
      : _runnable(runnable),
        _symbols(symbols),
        _pos(pos),
        _es(es),
        _slippage(slippage),
        _commission(commission),
        _runnableRunInfoHandler(runnableRunInfoHandler),
        _chartManager(chartManager),
        _explicitTrades(explicitTrades) {
    assert(_symbols != 0);
    assert(_runnable != 0);
    assert(_es != 0);
    if (signalHandler != 0) _signalHandlers.push_back(signalHandler);
  }

  RunnableInfo(Runnable* runnable, DataInfoIteratorPtr symbols, PositionsVector& pos, ErrorEventSink* es,
               const std::vector<SignalHandler*>& signalHandlers, RunnableRunInfoHandler* runnableRunInfoHandler,
               Slippage* slippage, Commission* commission, chart::ChartManager* chartManager,
               const ExplicitTrades* explicitTrades)
      : _runnable(runnable),
        _symbols(symbols),
        _pos(pos),
        _es(es),
        _slippage(slippage),
        _commission(commission),
        _signalHandlers(signalHandlers),
        _runnableRunInfoHandler(runnableRunInfoHandler),
        _chartManager(chartManager),
        _explicitTrades(explicitTrades) {
    assert(_symbols != 0);
    assert(_runnable != 0);
    assert(_es != 0);
  }

  virtual ~RunnableInfo() {}

  void runSymbol(const std::string& threadName, DataInfoConstPtr si, DateTimeRangePtr range, PositionsContainer::PositionsContainerPtr pc, DateTime startTradesDateTime,
    PositionsManagerImpl& pos ) {
    chart::Chart* chart = 0;
    double dataDuration = 0;
    double runnableDuration = 0;
    unsigned __int64 dataSize = 0;
    bool exitCall = false;
    try {
      Timer dataTimer;
      BarsPtr data = si->dataSource()->getData(si.get(), range)->getDataCollection();
      if (data.get() != 0) {
        dataSize = data->size();
      }

      if (data->hasInvalidData()) {
        // we got here because we are in data warning mode (otherwise
        // there would have been an exception)
        addErrorEvent(std::make_shared< ErrorEvent >(ErrorEvent::Types::INVALID_DATA, ErrorEvent::Category::warning, getRunnableName(), data->getInvalidDataAsString(), si->symbol().symbol()));
      }

      if (_explicitTrades != 0) {
        // now process explicit trades that are before the
        // startTradesDateTime The way things work: if a
        // startTradesDate is specified, all explicit trades before
        // that date are automatically generated, and the system
        // generates trades after that date We use a new position
        // manager with no start date set, as the date will be
        // controlled from within the toPositions todo: change this,
        // everything should be controlled from the manager, so this
        // manager would have a different range
        PositionsManagerImpl pos1(pc, NegInfinityDateTime(), startTradesDateTime);
        pos1.setSystemName("explicit trade");

        _explicitTrades->toPositions(Positions(&pos1), si->symbol(), data, NegInfinityDateTime(), startTradesDateTime);
      }

      dataDuration = dataTimer.elapsed();

      LOG(log_info, threadName, " : ", _runnable->name(), " on \"", si->symbol().symbol(), "\"");

      Timer runnableTimer;
      bool wasCleanup = false;
      try {
        chart = _chartManager->getChart(si->symbol().symbol());
        if (chart == 0) {
          LOG(log_info, "RunnableInfo::run - chartHandler is 0");
        }
        // if the symbol must not be charted, a NullChartHandler is
        // returned, so it will never return 0
        assert(chart != 0);
        // init the chart handler
        // new - adding a chart handler, so user code can generate
        // charts
        chart->init(data, pc);

        pos.setSystemName(_runnable->name());
        pos.setSystemId(_runnable->getUserString());

        // init the runnable - set the default bars, positions, data
        // manager and series manager
        //  todo: if chartHandler is 0, pass a default chart handler
        //  that doesn't do anything
        _runnable->init(data.get(), &pos, chart, _explicitTrades);
        // call the preRun method - give the runnable a chance to stop
        // before it starts
        if (_runnable->init(si->symbol().symbol())) {
          // run the runnable
          _runnable->run();
          // mark that we are entering cleanup, in case exceptions are
          // thrown there
          wasCleanup = true;
          _runnable->cleanup();
        }
      }
      catch (...) {
        // catching all exceptions so we can do cleanup first
        // this test is so we don't get into an infinite loop when
        // cleanup itself is throwing an exception
        if (!wasCleanup) {
          // mark that we are calling cleanup
          wasCleanup = true;
          _runnable->cleanup();
        }
        // now rethrow to handle the actual exception
        throw;
      }
      runnableDuration = runnableTimer.elapsed();
      // we are here because there are no errors, so send the status
      if (_runnableRunInfoHandler != 0) {
        // there were no errors
        _runnableRunInfoHandler->status(RunnableRunInfo(_runnable->name(), si->symbol().symbol(), dataDuration, runnableDuration, dataSize, false, threadName));
      }
    }
    catch (const ExitRunnableException&) {
      exitCall = true;
      throw;
    }
    catch (...) {
      LOG(log_info, "Runtime error \"", _runnable->name(), "\" on \"", si->symbol().symbol(), "\"");
      // first catch all exceptions to signal the status, and disable the
      // chart
      if (_runnableRunInfoHandler != 0) {
        // there were errors
        _runnableRunInfoHandler->status(RunnableRunInfo(_runnable->name(), si->symbol().symbol(), dataDuration, runnableDuration, dataSize, true, threadName));
      }

      // only stop charting if there were real errors, if it's an exit,
      // then still chart
      if (chart != 0 && !exitCall) {
        chart->setError("Trading system runtime error - no chart has been generated for this symbol");
      }
      // then re-throw for handling
      throw;
    }

  }

  /**
   * runs the Runnable on a range of the available data
   * If first initializes it with all the information such as the collection
   * of data elements on which to run it, the positions collection etc.
   *
   * It loads as much data as is specified by the range parameter. The range
   * parameter can be any type of range, time, bars indexes, a set of smaller
   * ranges etc as it is a polymorphic class
   *
   * This method also captures all runtime errors triggered by the Runnable and
   * sends them to the ErrroEventSink
   *
   * The cancelStat is reference to a flag that indicates whether the Runnable
   * should cancel its run. This flag is set if a cancel command is given by the
   * user code
   *
   * @param cancelState
   *               reference to flag indicating whether the Runnable should
   * abort
   * @param range  The range of data on which to run the Runnable
   * @return
   * @exception DataSourceException
   */
  bool run(const std::string& threadName, const std::atomic_bool& cancelState, DateTimeRangePtr range, DateTime startTradesDateTime){
    do {
      // called before the first symbol, to signal that a new simulation session
      // is starting if false, then stop running this runnable
      if (!_runnable->begin()) break;

      try {
        for (DataInfoConstPtr si = _symbols->getNext(); si.get() != 0; si = _symbols->getNext()) {
          Timer t;
          //        std::auto_ptr< const SymbolInfo > psi( si );
          // creating an empty  local list of positions, which will contain
          // positions for the current run of the runnable.
          PositionsContainer::PositionsContainerPtr pc = _pos.getNewPositionsContainer();
          // creating a positions object, which will be passed to the runnable.
          // This positions object contains a pointer to the positions list
          // object
          PositionsManagerImpl pos(pc, startTradesDateTime, PosInfinityDateTime(), _slippage, _commission);

          pos.registerSignalHandlers(_signalHandlers);

          // get the pointer to the bars object

          try {
              runSymbol( threadName, si, range, pc, startTradesDateTime, pos );
          }
          ERROR_EVENT_HANDLER(BarException, INVALID_DATA)
          ERROR_EVENT_HANDLER(DataSourceException, DATA_SOURCE_ERROR)
          ERROR_EVENT_HANDLER(GeneralSystemException, GENERAL_SYSTEM_ERROR)
          ERROR_EVENT_HANDLER(PositionIdNotFoundException, POSITION_ID_NOT_FOUND_ERROR)
          ERROR_EVENT_HANDLER(SystemException, GENERAL_SYSTEM_ERROR)
          ERROR_EVENT_HANDLER(BarIndexOutOfRangeException, BAR_INDEX_OUT_OF_RANGE_ERROR)
          ERROR_EVENT_HANDLER(InvalidLimitPriceException, INVALID_LIMIT_PRICE_ERROR)
          ERROR_EVENT_HANDLER(InvalidStopPriceException, INVALID_STOP_PRICE_ERROR)
          ERROR_EVENT_HANDLER(SeriesIndexOutOfRangeException, SERIES_INDEX_OUT_OF_RANGE_ERROR)
          ERROR_EVENT_HANDLER(TimeSeriesIndexOutOfRangeException, TIME_SERIES_INDEX_OUT_OF_RANGE_ERROR)
          ERROR_EVENT_HANDLER(SynchronizedSeriesIndexOutOfRangeException, SYNCHRONIZED_SERIES_INDEX_OUT_OF_RANGE_ERROR)
          ERROR_EVENT_HANDLER(CoveringLongPositionException, COVERING_LONG_POSITION_ERROR)
          ERROR_EVENT_HANDLER(SellingShortPositionException, SELLING_SHORT_POSITION_ERROR)
          ERROR_EVENT_HANDLER(ClosingAlreadyClosedPositionException, CLOSING_ALREADY_CLOSED_POSITION_ERROR)
          ERROR_EVENT_HANDLER(OperationOnUnequalSizeSeriesException, OPERATION_ON_UNEQUAL_SIZE_SERIES_ERROR)
          catch (const DivideByZeroException& e) {
            // dummy division with a NaN (not a number) result.
            double x = 100.0 / 50.0;
            ERROR_EVENT(FLOATING_POINT_DIVIDE_BY_0_ERROR);
          }
          ERROR_EVENT_HANDLER(AccessViolationException, ACCESS_VIOLATION_ERROR)
          ERROR_EVENT_HANDLER(SignalHandlerException, SIGNAL_HANDLER_ERROR)
          ERROR_EVENT_HANDLER(InvalidIndexForOperationException, INVALID_INDEX_FOR_OPERATION_EXCEPTION)
          ERROR_EVENT_HANDLER(SeriesSynchronizerException, SERIES_SYNCHRONIZER_ERROR)
          ERROR_EVENT_HANDLER(chart::ChartException, CHART_ERROR)
          ERROR_EVENT_HANDLER(OperationOnSeriesSyncedToDifferentSynchronizers, OPERATION_ON_SERIES_SYNCED_TO_DIFFERENT_SYNCHRONIZERS_ERROR)
          ERROR_EVENT_HANDLER(PositionCloseOperationOnOpenPositionException, POSITION_CLOSE_OPERATION_ON_OPEN_POSITION_ERROR)
          ERROR_EVENT_HANDLER(PositionZeroPriceException, POSITION_ZERO_PRICE_ERROR)
          ERROR_EVENT_HANDLER(OperationNotAllowedOnSynchronizedseriesException, OPERATION_NOT_ALLOWED_ON_SYNCHRONIZED_SERIES_ERROR)
          catch (const ExitRunnableException& e) {
            ERROR_EVENT(EXIT_STATMENT_CALL);
            return false;
          }
          ERROR_EVENT_HANDLER(InvalidBarsCollectionException, INVALID_BARS_COLLECTION_ERROR)
          ERROR_EVENT_HANDLER(ArrayIndexNotFoundException, ARRAY_INDEX_NOT_FOUND_ERROR)
          ERROR_EVENT_HANDLER(DictionaryKeyNotFoundException, DICTIONARY_KEY_NOT_FOUND_ERROR)
          ERROR_EVENT_HANDLER(InvalidPositionException, INVALID_POSITION_ERROR)
          ERROR_EVENT_HANDLER(ClosingPostionOnDifferentSymbolException, CLOSING_POSITION_ON_DIFFERENT_SYMBOL_ERROR)
          catch (...) {
            // catch any other unhandled exceptions
            ERROR_EVENT_MESSAGE_SYMBOL(UNKNOWN_APPLICATION_ERROR, "Unknown error", "");
          }
          // exit if cancel signaled
          if (cancelState) return false;
        }
      }
      catch (const DataInfoException&) {
        ERROR_EVENT_MESSAGE_SYMBOL(DATA_INFO_ERROR, "Data info invalid, possibly a null symbol", "");
      }
    }
    // repeats the loop until the runnable returns true, indicating that it has
    // finished its work
    while (_runnable->again());
    return true;
  }
};

/**
 * A collection of RunnableInfo's implemented as a vector to pointers to
 * RunnableInfo instances
 *
 * This is used by the Scheduler to store RunnableInfo instances created when
 * the user code adds new Runnable instances to the Scheduler
 *
 * A RunnableInfoList stores a reference to a "current" RunnableInfo, and has
 * a getNext method, both of which are used to iterate through the list
 * of all RunnableInfo instances and run the associated Runnable.
 *
 * This class is thread safe, in that different threads can call its methods
 * simultaneously and the access to data will be safely serialized. This is
 * necessary as each thread will have to call into this class to get the next
 * RunnableInfo that has the info for the Runnable to be run.
 *
 * @see PVector
 * @see RunnableInfo
 * @see Scheduler
 */
class RunnableInfoList : public PtrVector<RunnableInfo> {
  OBJ_COUNTER(RunnableInfoList)
 private:
  unsigned int _crt;
  mutable std::mutex _mutex;
  const std::string _name;

 public:
  /**
   * Constructor - takes the name
   *
   * Also resets the "current" value to point to the first element in the list
   *
   * @param name   The name
   */
  RunnableInfoList(const std::string& name) : _crt(0), _name(name) {}

  void reset() {
    std::scoped_lock lock(_mutex);
    _crt = 0;
  }

  /**
   * Returns the next available RunnableInfo and increments the "current" value
   * to point to the following one.
   *
   * if there are no more RunnableInfo in the collection, return null.
   *
   * @return A pointer to a RunnableInfo or 0 if no more available
   */
  std::shared_ptr< RunnableInfo > getNext() {
    std::scoped_lock lock(_mutex);

    std::shared_ptr< RunnableInfo > p = _crt < size() ? at(_crt++) : 0;
    return p;
  }
};

/**
 * This implements a thread of execution for Runnable instances.
 *
 * Each new thread created by the Scheduler will have a RunnableThread object
 * associated
 *
 * The thread runs in the operator() method of this object.
 *
 * A RunnableThread has
 * - a reference to a RunnableInfoList where it will get the next
 * RunnableInfo to run.
 * - the name of the thread
 * - the range on which to run all Runnable instances in the current thread
 * - a ThreadInitializer, used to do a one time thread initialization.
 *
 * @see Scheduler
 * @see RunnableInfoList
 * @see SynchronizedFlag
 * @see Range
 */
class RunnableThread {
 private:
  RunnableInfoList& _runnables;
  const unsigned int _index;
  const std::string _name;
  const std::atomic_bool& _cancelState;
  DateTimeRangePtr _range;
  const DateTime _startTradesDateTime;
  ThreadInitializer* _threadInitializer;
  const bool _cpuAffinity;

 public:
  /**
   * Constructor - takes all parameters needed to intialize the object as
   * parameters
   *
   * @param systems Reference to the RunnableInfoList object
   * @param name    The name of the thread
   * @param cancelState
   *                Reference to the cancelState flag indicating whether to
   * abort or not
   * @param range   Pointer to a range object
   * @param threadInitializer
   *                pointer to a thread initializer
   * @see ThreadInitializer
   * @see Range
   * @see SynchronizedFlag
   * @see RunnableInfoList
   */
  RunnableThread(RunnableInfoList& systems, unsigned int index, const std::string& name, const std::atomic_bool& cancelState,
                 DateTimeRangePtr range, ThreadInitializer* threadInitializer, bool cpuAffinity, DateTime startTradesDateTime)
      : _runnables(systems),
        _index(index),
        _name(name),
        _cancelState(cancelState),
        _range(range),
        _threadInitializer(threadInitializer),
        _cpuAffinity(cpuAffinity),
        _startTradesDateTime(startTradesDateTime) {}

  virtual ~RunnableThread() {}

  /**
   * operator() - called when the new thread starts/
   *
   * This function gets called when the thread starts. It will iterate through
   * the list of RunnableInfo until the iterator points to the end of the list.
   *
   * For each RunnableInfo in the list it will run the associated Runnable.
   *
   * Multiple threads will iterate through the same list, so each thread will
   * get to run only a subset of all the RunnableInfo instances in the list.
   *
   * Because of this algorithm, all threads created by a Scheduler will be busy
   * until the itertor points to the end of the list, meaning that all the
   * Runnable have been run.
   *
   * In order to run one runnable in multiple threads, create multiple instances
   * of the same runnable and use one symbols list iterator for all of them
   *
   * @see The thread function.
   * @see This operator gets called when the thread starts. It will iterate
   * through the
   * @see list of RunnableInfo and for each RunnableInfo will run the associated
   * Runnable.
   * @see Multiple threads will iterate through the same lists
   */
  void operator()() {
    if (_cpuAffinity) {
      setCurrentThreadIdealProcessor(_index);
    }
    if (_threadInitializer != 0) {
      _threadInitializer->init();
    }
    StructuredException::install();
    bool f = true;

    for (std::shared_ptr< RunnableInfo > si = _runnables.getNext(); si != 0 && f; si = _runnables.getNext()) {
      f = si->run(_name, _cancelState, _range, _startTradesDateTime);
    }

    if (_threadInitializer != 0) {
      _threadInitializer->uninit();
    }
  }
};

/**
 * Definition of a ThreadVector
 *
 * @see RunnableThread
 * @see PtrVector
 */
using ThreadVector = PtrVector<RunnableThread>;
/**
 * Prototype for the actual thread function that will be called when the
 * Runnable are run in asyncronous mode
 *
 * @param param  Pointer to an arbitrary parameter to be passed to the thread.
 * In our case this parameter will be a pointer to a AsynchRunInfo object
 * @see Scheduler
 */
void thread_func(void* param);

class SchedulerImpl;

/**
 * contains the information needed by the thread function when the Scheduler
 * nees to run the Runnable asynchronously, meaning the Scheduler run method
 * will return immediately without waiting for all Runnable to complete their
 * runs
 *
 * The information contains the Scheduler instance that is running the Runnable,
 * and the range on which it is running them
 *
 * @see Scheduler
 * @see thread_func
 */
class AsynchRunInfo {
 private:
  SchedulerImpl* _scheduler;
  DateTimeRangePtr _range;
  const DateTime _startTradesDateTime;
  unsigned long _threads;
  bool _cpuAffinity;

 private:
  AsynchRunInfo(const AsynchRunInfo& ari) {}

  const AsynchRunInfo& operator=(const AsynchRunInfo& ari) { return *this; }

 public:
  /**
   * Constructor - takes the scheduler object as parameter and sets the range to
   * "all" (0)
   *
   * @see Scheduler
   */
  AsynchRunInfo(SchedulerImpl* scheduler) : _scheduler(scheduler), _range(0) {}

  /**
   * Constructor - takes the scheduler object as parameter and a range
   *
   * @see Scheduler
   * @see Range
   */
  AsynchRunInfo(SchedulerImpl* scheduler, unsigned long threads, bool cpuAffinity, DateTimeRangePtr range, DateTime startTradesDateTime)
      : _scheduler(scheduler),
        _range(range),
        _threads(threads),
        _cpuAffinity(cpuAffinity),
        _startTradesDateTime(startTradesDateTime) {}

  /**
   * Returns the Scheduler
   *
   * @return the Scheduler
   */
  SchedulerImpl* getScheduler() { return _scheduler; }

  /**
   * returns the Range
   *
   * @return the Range
   */
  DateTimeRangePtr getRange() const { return _range; }

  unsigned long threads() const { return _threads; }
  bool getCPUAffinity() const { return _cpuAffinity; }
  DateTime startTradesDateTime() const { return _startTradesDateTime; }
};

/**
 * The Scheduler implementation
 *
 * It coordinates the running of the Runnables in the specified number of
 * threads
 */
class SchedulerImpl : public Scheduler {
 private:
  RunnableInfoList _runnables;
  // this is just so the thread object be destroyed at the end

  mutable std::mutex m_mx;
  mutable std::condition_variable m_condition;

  std::atomic_bool _cancelState = false;
  std::atomic_bool _running = false ;
  ThreadInitializer* _threadInitializer;
  RunEventHandler* _runEventHandler;

  // a set of all signal handlers for the session. There are no duplicates here,
  // so if each runnable sends signals to the same signal handler, there will
  // only be one in this set. This is used by the scheduler to signal the start
  // and end of a session to all signal handlers for the session, without the
  // danger of sending multiple notifications to the same handler
  std::set<SignalHandler*> _signalHandlersSet;
  std::set<ErrorEventSink*> _errorSinkSet;

 public:
  /**
   * Constructor - takes the number of threads and a printStatus as parameters
   *
   * The number of threads indicates in how many threads all the Runnables will
   * be run.
   *
   * The printstatus is a debug feature - in command line mode it will print out
   * to the console the status of the Scheduler
   *
   * @param nbThreads The number of threads
   * @param printStatus
   *                  The print status
   */
  SchedulerImpl(RunEventHandler* runEventHandler = 0)
      : _runnables("Systems"),
        _threadInitializer(0),
        _runEventHandler(runEventHandler) {}

  virtual ~SchedulerImpl() {}

  /**
   * Sets the ThreadInitializer that will be used to initialize each of the
   * created threads
   *
   * @param threadInitializer
   *               pointer to a thread initializer object
   */
  virtual void setThreadInitializer(ThreadInitializer* threadInitializer) {
    _threadInitializer = threadInitializer;
  }

  /**
   * Adds a Runnable to the list of Runnables that will be run by the Scheduler
   *
   * Each Runnable is associated with a number of parameters:
   * - SymbolsListIterator - the iterator on the list of symbols will be run on
   * - PositionsContainer - a container of positions in which will the Runnable
   * will store the created positions
   * - ErrorEventSink - an even sink that will receive the runtime error events
   * - Slippage - the slippage
   * - Commission - the commission
   * - AlertHandler - the signal handler that will receive the signals triggered
   * by the Runnable
   *
   * @param runnable   The runnable to be added
   * @param s          the iterators on the list of symbols
   * @param pos        the positions container
   * @param es         the error event sink
   * @param slippage   the slippage
   * @param commission the commission
   * @param signalHandler
   *                   the signal handler
   * @see Runnable
   * @see SymbolsListIterator
   * @see PositionsContainer
   * @see ErrorEventSink
   * @see Slippage
   * @see Commission
   * @see AlertHandler
   */
  void addRunnable(Runnable* runnable, DataInfoIteratorPtr s, PositionsVector& pos, ErrorEventSink* es,
                   SignalHandler* signalHandler = 0, RunnableRunInfoHandler* runnableRunInfoHandler = 0,
                   Slippage* slippage = 0, Commission* commission = 0, chart::ChartManager* chartManager = 0,
                   const tradery::ExplicitTrades* explicitTrades = 0) {
    try {
      _runnables.push_back(std::make_shared< RunnableInfo>( runnable, s, pos, es, signalHandler, runnableRunInfoHandler, slippage, commission, chartManager, explicitTrades));
      _signalHandlersSet.insert(signalHandler);
      _errorSinkSet.insert(es);
    }
    catch (const std::bad_cast&) {
      // TODO: throw an exception for the user to tell him he cannot derive from
      // PositionsContainer
      assert(false);
    }
  }

  void addRunnable(Runnable* runnable, DataInfoIteratorPtr s, PositionsVector& pos, ErrorEventSink* es,
                   const std::vector<SignalHandler*>& signalHandlers, RunnableRunInfoHandler* runnableRunInfoHandler = 0,
                   Slippage* slippage = 0, Commission* commission = 0, chart::ChartManager* chartManager = 0,
                   const tradery::ExplicitTrades* explicitTrades = 0) {
    try {
      _runnables.push_back( std::make_shared< RunnableInfo >(runnable, s, pos, es, signalHandlers, runnableRunInfoHandler, slippage, commission, chartManager, explicitTrades) );
      for (auto signalHandler : signalHandlers ) {
        _signalHandlersSet.insert(signalHandler);
      }
      _errorSinkSet.insert(es);
    }
    catch (const std::bad_cast&) {
      // TODO: throw an exception for the user to tell him he cannot derive from
      // PositionsContainer
      assert(false);
    }
  }

  void resetRunnables() { _runnables.clear(); }

  /**
   * Indicates the status running or resting of the scheduler.
   *
   * @return Returns true if it is running, false if resting
   */
  bool isRunning() const { return _running; }

  /**
   * Indicates the status canceling of the Scheduler
   *
   * @return Returns true if it's canceling, false otherwise
   */
  bool isCanceling() const { return _cancelState; }

  /**
   * Starts running the Runnable objects in the list of runnables
   *
   * The run can be synchronous or asynchronous, depending on the parameter
   * "asynch".
   *
   * If run synchronously, run will return only after all the Runnable have
   * completed their run If run asynchronously, run will return immediately,
   * regardless of the running status of the Runnable instances
   *
   * @param asynch indicates whether to run asynchronously (true) or
   * synchronously (false)
   * @param range  The range of data on which to run the Runnables
   */
  void run( bool asynch, unsigned long threads, bool cpuAffinity, DateTimeRangePtr range, DateTime startTradesDateTime) {
    if (isRunning()) {
      throw SchedulerReentrantRunCallException();
    }

    _running = true;
    if (asynch) {
      _beginthread(thread_func, 0, new AsynchRunInfo(this, threads, cpuAffinity, range, startTradesDateTime));
    }
    else {
      run(threads, cpuAffinity, range, startTradesDateTime);
    }
  }

  /**
   * Cancels the current run synchronously, meaning that the method will return
   * only after the run has been canceled

   This code has not been tested after the change to std::condition as it is not used anymore
   the assumption is a session will always complete, or if not needed, the processed will be killed

   TODO: Test if it becomes useful again
   */
  void cancelSync() override {
    std::unique_lock< std::mutex > lock(m_mx);
    cancelAsync();

    m_condition.wait_for(lock, 0s, [this]()->bool { return !isRunning(); });
   }

  /**
   * Cancels the current run asynchronously, meaning that the method will return
   * immediately, without waiting for the run to be canceled
   */
  void cancelAsync() override {
    _cancelState = true;
    if (_runEventHandler != 0) {
      _runEventHandler->runCanceled();
    }
  }

  void run(unsigned long threads, bool cpuAffinity, DateTimeRangePtr range, DateTime startTradesDateTime) {
    // synchronous run relative to the calling function
    if (_runEventHandler != 0) {
      _runEventHandler->runStarted();
    }

    // only run if there are no errors
    _running = true;
    _runnables.reset();
    boost::thread_group _threads;
    ThreadVector _threadVector;

    for (unsigned int n = 0; n < threads; n++) {
      _threadVector.push_back(std::make_shared< RunnableThread >( _runnables, n, std::to_string(n), _cancelState, range, _threadInitializer, cpuAffinity, startTradesDateTime) );
      _threads.create_thread( *_threadVector.back());
    }
    _threads.join_all();

    _running = false;
    _cancelState = false;
    m_condition.notify_all();

    LOG(log_debug, "session ended");
    if (_runEventHandler != 0) _runEventHandler->runEnded();
  }
};
