<html>

<head>
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>New Page 1</title>
<style>
<!--
code         { font-family: Courier New }
-->
</style>
</head>

<body>

<p>As described in the plug-in configuration API and session events API 
sections, each plug-in configuration can interact with the current session 
through a SessionInfo object. Among other parameters, the SessionInfo class 
gives access to all the session data and symbols. This feature is particularly 
important for trading systems, implemented as Runnable plug-ins, that require 
data from multiple symbols in order to make trading decisions. For example, a 
trading system may use market data for an index symbol such as QQQQ, VIX etc, to 
assess the general state of the market. This data can then be used to choose a 
variety of position entry/exit or sizing strategies for the current default 
symbol.</p>
<p>The sample system System5 which is part of the systemsplugin1 sample project 
illustrates several basic techniques used in multi-symbol systems. All the 
relevant code is located inside the method init.</p>
<h3>Getting data</h3>
<p>To get the data for any symbol that the data source associated with the 
session can provide, the method getBars should be called. If the data is 
available, the method returns a pointer to the collection of bars that has the 
session set parameters such as time range. If the data is not available, the 
method will return 0.</p>

<table border=0 cellpadding=0 width="100%" style='width:100.0%;mso-cellspacing:
 1.5pt'>
 <tr>
 	<code>
  <td width="100%" style='width:100.0%;background:#C4DDD7;padding:.75pt .75pt .75pt .75pt'>
 	<code>
  <font COLOR="#008000">// get data for msft<br>
  </font><font COLOR="#0000ff">const</font> Bars* 
  msft = getBars( _TT( &quot;msft&quot; ) );</code></td>
  </code>
 </tr>
</table>

<h3>Getting symbols</h3>
<p>The method symbolsIterator returns a pointer to a SymbolsIterator for the 
symbols source associated with the current session. All symbols can be accessed 
by calling the methods SymbolsIterator::getNext. The reset method must be called 
to ensure the iterator points to the first available symbol.</p>

<table border=0 cellpadding=0 width="100%" style='width:100.0%;mso-cellspacing:
 1.5pt'>
 <tr>
 	<code>
  <td width="100%" style='width:100.0%;background:#C4DDD7;padding:.75pt .75pt .75pt .75pt'>
  	<code>
  <font COLOR="#008000">// get the current SymbolsIterator</font><br>
  </code>
  SymbolsIterator* si = symbolsIterator();<font COLOR="#008000"><br>
  // reset the symbols iterator, so it 
  will point to the first symbol</font><br>
  si-&gt;reset();<font COLOR="#008000"><br>
  // get the first symbol</font><br>
  SymbolConstPtr firstSymbol = si-&gt;getNext();</td>
  </code>
 </tr>
</table>

<p>Besides symbols returned by the SymbolsIterator for the default session 
symbols source, a trading system developer can use any other symbol, as long as 
the session default data source is capable of retrieving the data for it.</p>
<p>Note: the order and number of symbols returned by calls to a symbol iterator 
depend on the symbols source that iterator is associated with. If the symbols 
source is simply reading symbols from a static text file, than the behavior of 
the symbols iterator is predictable, or at least can be repeated. If the symbols 
source is dynamic, i.e. it determines the symbols on the fly, the iterator may 
not return symbols in a consistent manner, when called repeatedly after a reset.</p>
<h3>Synchronizing data for different data collections and data series</h3>
<p>In order to use data from different symbols in the same bar loop, the same 
bar index must correspond to bars with the same time stamp for all the data 
collections, or in other words, these data collections must be synchronized. In 
general, no assumption can be made about the data returned by data sources as 
far as their synchronized or unsynchronized status, so synchronization must be 
performed by the trading system itself.</p>
<p>The same issue is true in the case of data series generated by applying 
various technical indicators to data collections. Note that technical indicators 
must be applied to the original data collections and not the synchronized ones, 
in order to get accurate values, and the generated series themselves must be 
synchronized.</p>
<p>The classes that can be used for data synchronization are DataSynchronizer 
and SeriesSynchronizer.</p>
<p>DataSynchronizer is used to synchronize 2 data collection. The constructor 
takes two data collections - the first being the reference, and the second the 
collection to synchronize. DataSynchronizer implements the interface 
BarsAccessor and it is in fact a synchronized &quot;view&quot; into the original, 
un-synchronized collection, so after creating a DataSynchronizer object, all 
access to synchronized data is done through it. Internally, this is done by 
creating a mapping between synchronized and non-synchronized indexes, so that 
the same index applied to the reference data collection and the DataSynchronizer 
object return values corresponding to bars with the same timestamp.</p>

<table border=0 cellpadding=0 width="100%" style='width:100.0%;mso-cellspacing:
 1.5pt'>
 <tr>
 	<code>
  <td width="100%" style='width:100.0%;background:#C4DDD7;padding:.75pt .75pt .75pt .75pt'>
 	<code>
  <font COLOR="#0000ff">const</font> Bars&amp; bars1;<font COLOR="#008000"><br>
  </font><font COLOR="#0000ff">const</font> Bars* bars2;<font COLOR="#008000"><br>
  // create a synchronization object that synchronizes the bars1 to bars2</font><br>
  DataSynchronizer ds( bars1, bars2 );<br>
  <br>
  <font COLOR="#0000ff">for</font>( size_t n = 
  0; n &lt; bars1.size(); n++ )<br>
  {<br>
&nbsp; DateTime timeStamp1 = bars1.getTime( n );<br>
  <font COLOR="#008000">&nbsp; // access synchronized data from bars2 through ds<br>
  </font>&nbsp; DateTime timeStamp2 = ds.getTime( n );<br>
&nbsp; <br>
  <font COLOR="#008000">&nbsp; // the two timestamps must be the same<br>
  </font>&nbsp; <font color="#0000FF">if</font>( timeStamp1 != timeStamp2 )<br>
&nbsp;&nbsp;&nbsp; <font color="#0000FF">throw </font>exception()<font color="#0000FF">;</font><br>
  }</code></td>
  </code>
 </tr>
</table>

<p>Similarly to DataSynchronizer, a SeriesSynchronizer implements the interface 
SeriesAccessor, and it represents a synchronized &quot;view&quot; into an un-synchronized 
series. First a DataSynchronizer must be created. Then, one or more data series 
are created using indicators applied to the unsynchronized data collection (as 
explained above, this needs to be done this way to preserve data accuracy in 
generated series). Then a SeriesSynchronizer object is constructed using the 
previously created DataSynchronizer and the unsynchronized series as parameters 
to the constructor.</p>

<table border=0 cellpadding=0 width="100%" style='width:100.0%;mso-cellspacing:
 1.5pt'>
 <tr>
 	<code>
  <td width="100%" style='width:100.0%;background:#C4DDD7;padding:.75pt .75pt .75pt .75pt'>
 	<code>
  <font COLOR="#0000ff">const</font> Bars&amp; bars1;<font COLOR="#008000"><br>
  </font><font COLOR="#0000ff">const</font> Bars* bars2;<font COLOR="#008000"><br>
  // create a synchronization object that synchronizes the bars1 to bars2</font><br>
  DataSynchronizer ds( bars1, bars2 );<br>
  <br>
  </code>
 	<code>
  <font COLOR="#008000">// first create a series that is the sma( 5 ) of the 
  closing prices series of bars2</font><br>
  </code>
 	<code>
  <font COLOR="#008000">// then create the series synchronizer object to 
  synchronize it to the bars1 series</font><br>
  </code>
  SeriesSynchronizer ss( ds, bars2-&gt;getCloseSeries().SMA( 5 ) );<br>
  <br>
  <font COLOR="#008000">// now add the synchronized series to the closing series 
  of bars1 and create a new psum series</font><br>
  SeriesConstPtr psum = bars1-&gt;getCloseSeries() + ss;</td>
  </code>
 </tr>
</table>

<p>SeriesSynchronizer has 3 constructors that take a SeriesCosntPtr, a const 
const Series* and a const Series&amp;. The type of ownership of the series parameter 
depends on the constructor - the first two take partial or total ownership of 
the series, while the third one doesn't take any ownership. This behavior was 
chosen to cover typical use cases, such as series pointers generated as 
temporary objects, or others, and they normally make the code simpler and easier 
to understand. In some cases however, the wrong constructor may be chosen, and a 
series may remain allocated after it has gone out of scope or a series may be 
deallocated unintendedly, while still being used in other parts of the code, so 
care must be taken to select the constructor with the right behavior, for 
example by passing a reference instead of a pointer or vice versa, depending on 
the situation.</p>

</body>

</html>