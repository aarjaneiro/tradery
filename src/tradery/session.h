/*
   Copyright (C) 2018-2020 Adrian Michel

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#pragma once

#include <enum.h>

#include "Document.h"
#include <charthandler.h>
#include "tradery.h"

class RestartingNotWaitingSessionException {};

class StartingActiveSessionException {};

class SymbolsSourceNotAvailableException {};

class Running {
 public:
  virtual ~Running() {}

  virtual bool isRunning() const = 0;
};

class TASessionException {
 private:
  const std::string _message;

 public:
  TASessionException(const std::string& message) : _message(message) {}

  const std::string& message() const { return _message; }
};

struct SessionParams {
 public:
  // contains
  PositionsVector& _pos;

  // moves all positions in the first element of the vector
  // now the first element has all the positions generated by all systems,
  // ready for position sizing and stats processing
  PositionsContainer* populateAllPositions() {
    return _pos.populateAllPositions();
  }

  SessionParams(PositionsVector& pos) : _pos(pos) {}

  size_t posCount() const { return _pos.count(); }

  void sendPositions(PositionHandler& pr, bool& cancel) {
    // now send all the generated trades to the list box, if enabled

    for (PositionsVector::const_iterator i = _pos.begin(); i != _pos.end() && !cancel; i++) {
      const PositionsContainer& pc = **i;

      pc.forEachConst(pr);
    }
  }

  void clear() { _pos.clear(); }

  bool exportPositionsCSV(std::ostream& os) const {
    PositionsContainerToCSV(_pos, os);

    return true;
  }

  PositionsVector& getPositionsVector() { return _pos; }
};

// counts something per run and per session
class Counter {
  unsigned long _runCount;
  unsigned long _sessionCount;
  mutable std::mutex _mx;

 public:
  Counter() : _runCount(0), _sessionCount(0) {}
  unsigned long runCount() const {
    std::scoped_lock lock(_mx);
    return _runCount;
  }
  unsigned long sessionCount() const {
    std::scoped_lock lock(_mx);
    return _sessionCount;
  }
  void reset() {
    std::scoped_lock lock(_mx);
    _runCount = _sessionCount = 0;
  }
  void resetRun() {
    std::scoped_lock lock(_mx);
    _runCount = 0;
  }
  void increment() {
    std::scoped_lock lock(_mx);
    _sessionCount++;
    _runCount++;
  }
  //	void increment( unsigned long inc ) { Lock lock( _mx ); _sessionCount +=
  // inc; _runCount += inc; }
};

class RunsCounter : protected ::Counter, public RunnableRunInfoHandler {
 private:
  RunnableRunInfoHandler* _receiver;

 public:
  RunsCounter() : _receiver(0) {}

  void setRunnableStatusReceiver(RunnableRunInfoHandler* receiver) {
    assert(receiver != 0);
    _receiver = receiver;
  }
  unsigned long currentRunsCount() const { return __super::runCount(); }
  unsigned long sessionRunsCount() const { return __super::sessionCount(); }
  virtual void status(const RunnableRunInfo& status) {
    assert(_receiver != 0);
    __super::increment();
    _receiver->status(status);
  }
};

class TAErrorSink : public ErrorEventSink, protected ::Counter {
 private:
  ErrorEventSink* _sink;
  mutable std::mutex _mx;

 public:
  TAErrorSink() : _sink(0) {}
  virtual ~TAErrorSink() {}

 public:
  void setErrorSink(ErrorEventSink* sink) {
    std::scoped_lock lock(_mx);
    _sink = sink;
  }

  //////////////////////////////////////////////////////
  // ErrorEventSink methods
  virtual void push(const ErrorEventPtr event) {
    std::scoped_lock lock(_mx);
    __super::increment();
    assert(_sink != 0);
    _sink->push(event);
  }

  unsigned long runErrorCount() const { return __super::runCount(); }
  unsigned long sessionErrorCount() const { return __super::sessionCount(); }

  // unused methods
  virtual void pop() {}
  virtual ErrorEventPtr front() const { return ErrorEventPtr{}; }
  virtual bool empty() const { return true; }
  virtual size_t size() const { return 0; }
};

// a signal handler used inside the trading app GUI to count signals, dispatch
// signals etc.
class TASignalHandler : public SignalHandler, public ::Counter, public SessionEventHandlerDelegator {
 private:
  std::map<UniqueId, SignalHandler*> _signalHandlers;
  mutable std::mutex _mx;

 public:
  TASignalHandler()
      : SignalHandler(Info("C2CE160D-55E3-44a3-A7AE-EC751B1DA8DF", "", "")) {}

  ~TASignalHandler() {
    // there shuoldn't be any signal handlers upon destruction
    assert(_signalHandlers.size() == 0);
  }
  unsigned long runSignalCount() const { return __super::runCount(); }
  unsigned long sessionSignalCount() const { return __super::sessionCount(); }

  virtual void signal(SignalPtr signal) {
    std::scoped_lock lock(_mx);
    __super::increment();
    for (auto i : _signalHandlers) {
      i.second->signal(signal);
    }
  }

  void addSignalHandler(SignalHandler* signalHandler) {
    std::scoped_lock lock(_mx);
    _signalHandlers.insert(std::map<UniqueId, SignalHandler*>::value_type(signalHandler->id(), signalHandler));
    SessionEventHandlerDelegator::add(signalHandler);
  }

  void removeSignalHandler(const UniqueId& id) {
    std::scoped_lock lock(_mx);
    assert(_signalHandlers.find(id) != _signalHandlers.end());
    SessionEventHandlerDelegator::remove(_signalHandlers[id]);
    _signalHandlers.erase(id);
  }

  virtual void sessionStarted(SessionInfo& so) {
    SessionEventHandlerDelegator::sessionStarted(so);
  }

  virtual void sessionEnded(PositionsContainer& positions) {
    SessionEventHandlerDelegator::sessionEnded(positions);
  }

  virtual void sessionCanceled() {
    SessionEventHandlerDelegator::sessionCanceled();
  }

  virtual void runStarted() { SessionEventHandlerDelegator::runStarted(); }

  virtual void runCanceled() { SessionEventHandlerDelegator::runCanceled(); }

  virtual void runEnded() { SessionEventHandlerDelegator::runEnded(); }
};

class SessionRunTimer {
 private:
  mutable Timer _run;
  mutable Timer _session;

 public:
  double runElapsed() const { return _run.elapsed(); }
  double sessionElapsed() const { return _session.elapsed(); }
  void reset() {
    _run.restart();
    _session.restart();
  }
  void stop() {
    _run.stop();
    _session.stop();
  }
  void stopRun() { _run.stop(); }
  void resetRun() { _run.restart(); }
};


class DataSourceContext : public SessionEventHandlerDelegator {
  OBJ_COUNTER(DataSourceContext)
 private:
  std::shared_ptr<PluginInstance<DataSource> > _dataSourcePlugin;
  std::shared_ptr<DataSource> _dataSource;
  int _count;
  const PluginTree& pluginTree;

 public:
  DataSourceContext(const PluginTree& pluginTree)
      : _count(0), pluginTree(pluginTree) {}

  ~DataSourceContext() {
    // if an exception is thrown, the count may be one, in which case release
    if (_count == 1) release();
    assert(_count == 0);
  }

  DataSource* getDataSource() { return _dataSource.get(); }

  const UniqueId& id() const {
    assert(_dataSource.get() != 0);
    return _dataSource->id();
  }

  void create(const UniqueId& id, const std::vector<std::string>* defStrings) {
    assert(!_dataSource || _dataSource->id() == id);

    if (_count == 0) {
      // we are sure that there are default values for datasource and
      // symbolssource, so the pointers cannot be 0

      try {
        const UniqueId* parent(pluginTree.parent(id));
        // todo: handle this case too
        assert(parent != 0);
        _dataSourcePlugin = pluginTree.getPlugin<DataSource, Node::NodeType::DATASOURCE>(*parent);
        _dataSource = (*_dataSourcePlugin)->get(id, defStrings);
        SessionEventHandlerDelegator::add(_dataSource.get());
      }
      catch (const IdNotFoundException& e) {
        throw TASessionException(tradery::format("Data Source ", e.id().str(), " not found"));
      }
      catch (const WrongPluginTypeException& e) {
        throw TASessionException(e.message());
      }
    }
    _count++;
  }

  void set(std::shared_ptr<PluginInstance<DataSource> > pi,
    std::shared_ptr<DataSource> ds) {
    assert(_count == 0);
    assert(_dataSourcePlugin.get() == 0);
    assert(!_dataSource);

    _dataSourcePlugin = pi;
    _dataSource = ds;
    _count++;
    SessionEventHandlerDelegator::add(_dataSource.get());
  }

  void release() {
    _count--;
    assert(_count >= 0);
    if (_count == 0) {
      if (_dataSourcePlugin.get() != 0) {
        SessionEventHandlerDelegator::remove(_dataSource.get());
      }
    }
  }
};

class SymbolsSourceContext : public SessionEventHandlerDelegator {
 private:
  std::shared_ptr<PluginInstance<SymbolsSource> > _symbolsSourcePlugin;
  std::shared_ptr<SymbolsSource> _symbolsSource;
  int _count;
  const PluginTree& pluginTree;

 public:
  SymbolsSourceContext(const PluginTree& pluginTree)
      : _symbolsSourcePlugin(0), _count(0), pluginTree(pluginTree) {}

  ~SymbolsSourceContext() {
    // if an exception is thrown, the count may be one, in which case release
    if (_count == 1) release();
    assert(_count == 0);
  }

  const UniqueId& id() const {
    assert(_symbolsSource);
    return _symbolsSource->id();
  }

  // returns the number of symbols in the default symbols source
  unsigned __int64 symbolsCount() const {
    if (_symbolsSource) {
      return _symbolsSource->size();
    }
    else {
      throw SymbolsSourceNotAvailableException();
    }
  }

  void create(const UniqueId& id, const std::vector<std::string>* createStrings) {
    assert(!_symbolsSource || _symbolsSource->id() == id);

    if (_count == 0) {
      try {
        const UniqueId* parent = pluginTree.parent(id);
        _symbolsSourcePlugin = pluginTree.getPlugin<SymbolsSource, Node::NodeType::SYMBOLSSOURCE>(*parent);
        _symbolsSource = (*_symbolsSourcePlugin)->get(id, createStrings);
        SessionEventHandlerDelegator::add(_symbolsSource.get());
      }
      catch (const IdNotFoundException& e) {
        throw TASessionException(tradery::format("Symbols Source ", e.id().str(), " not found"));
      }
      catch (const WrongPluginTypeException& e) {
        throw TASessionException(e.message());
      }
      catch (const PluginException& e) {
        throw TASessionException(e.message());
      }
      catch (const SymbolsSourceException& e) {
        throw TASessionException(e.message());
      }
    }
    _count++;
  }

  void set(std::shared_ptr<PluginInstance<SymbolsSource> > pi,
    std::shared_ptr<SymbolsSource> ds) {
    assert(_count == 0);
    assert(_symbolsSourcePlugin.get() == 0);
    assert(!_symbolsSource);

    _symbolsSourcePlugin = pi;
    _symbolsSource = ds;
    SessionEventHandlerDelegator::add(_symbolsSource.get());
    _count++;
  }

  void release() {
    _count--;
    assert(_count >= 0);
    if (_count == 0) {
      if (_symbolsSourcePlugin.get() != 0) {
        SessionEventHandlerDelegator::remove(_symbolsSource.get());
        _symbolsSource.reset();
        _symbolsSourcePlugin.reset();
      }
    }
  }

  tradery::SymbolsIteratorPtr makeIterator() {
    return _symbolsSource->makeIterator();
  }
};

class SignalHandlerContext : public TASignalHandler {
 private:
  std::shared_ptr<PluginInstance<SignalHandler> > _signalHandlerPlugin;
  std::shared_ptr<SignalHandler> _signalHandler;
  int _count;
  const PluginTree& pluginTree;

 public:
  SignalHandlerContext(const PluginTree& pluginTree)
      : _signalHandlerPlugin(0), _count(0), pluginTree(pluginTree) {}

  ~SignalHandlerContext() {
    if (_count == 1) {
      release();
    }
    assert(_count == 0);
  }

  void create(const UniqueId& id, const std::vector<std::string>* createStrings) {
    assert(!_signalHandler || _signalHandler->id() == id);

    if (_count == 0) {
      try {
        const UniqueId* parent = pluginTree.parent(id);
        // todo: handle this case too
        assert(parent != 0);
        _signalHandlerPlugin = pluginTree.getPlugin<SignalHandler, Node::NodeType::SIGNALHANDLER>(*parent);
        _signalHandler = (*_signalHandlerPlugin)->get(id, createStrings);
        assert(_signalHandler);
        __super::addSignalHandler(_signalHandler.get());
      }
      catch (const IdNotFoundException& e) {
        throw TASessionException( tradery::format("Signal Handler ", e.id().str(), " not found"));
      }
      catch (const WrongPluginTypeException& e) {
        throw TASessionException(e.message());
      }
    }
    _count++;
  }

  void set(std::shared_ptr<PluginInstance<SignalHandler> > pi,
    std::shared_ptr<SignalHandler> ds) {
    assert(_count == 0);
    assert(_signalHandlerPlugin.get() == 0);
    assert(!_signalHandler);

    _signalHandlerPlugin = pi;
    _signalHandler = ds;
    __super::addSignalHandler(_signalHandler.get());

    _count++;
  }

  void release() {
    _count--;
    assert(_count >= 0);
    if (_count == 0) {
      if (_signalHandlerPlugin.get() != 0) {
        assert(_signalHandler);
        __super::removeSignalHandler(_signalHandler->id());
        _signalHandler.reset();
        _signalHandlerPlugin.reset();
      }
    }
  }
};

class SessionInfoImpl : public SessionInfo {
 private:
  mutable OutputSink* _os;
  const std::string _sessionName;
  DateTimeRangePtr _range;
  DataSource* _defDataSource;
  tradery::SymbolsIteratorPtr _si;
  const RuntimeParams* _runtimeParams;
  RuntimeStats* _runtimeStats;
  const UniqueId& _sessionId;

 public:
  SessionInfoImpl(const std::string& sessionName, const UniqueId& sessionId,
                  DataSource* defDataSource, DateTimeRangePtr range,
                  tradery::SymbolsIteratorPtr si,
                  const RuntimeParams* runtimeParams,
                  RuntimeStats* runtimeStats, OutputSink* os)
      : _os(os),
        _sessionName(sessionName),
        _range(range),
        _defDataSource(defDataSource),
        _si(si),
        _runtimeParams(runtimeParams),
        _runtimeStats(runtimeStats),
        _sessionId(sessionId) {
    assert(runtimeParams != 0);
    assert(os != 0);
    assert(si != 0);
  }

  /**
   * Returns the session name
   *
   * @return The session name
   */
  const std::string& sessionName() const { return _sessionName; }

  virtual OutputSink& outputSink() const {
    assert(_os != 0);
    return *_os;
  }

  virtual BarsPtr getData(const std::string& symbol) const {
    DataInfo di(_defDataSource, SymbolConstPtr(new Symbol(symbol)));

    try {
      return _defDataSource->getData(&di, _range)->getDataCollection();
    }
    catch (const exception& e) {
      LOG(log_error, _sessionId.str(), "exception getting data for symbol \"", symbol , "\": " , e.what());
      return BarsPtr();
    }
    catch (...) {
      LOG(log_error, _sessionId.str(), "unknown exception getting data for symbol \"", symbol);
      return BarsPtr();
    }
  }

  // each plug-in gets its own iterator
  virtual tradery::SymbolsIteratorPtr symbolsIterator() const { return _si; }

  virtual const RuntimeParams* runtimeParams() const { return _runtimeParams; }

  virtual RuntimeStats* runtimeStats() { return _runtimeStats; }
};

using SessionInfoPtr = std::shared_ptr<SessionInfo>;

class TASession : public Running,
                  public RunEventHandler,
                  public TAErrorSink,
                  public SessionRunTimer,
                  public RunsCounter {
 private:
  DataSourceContext _defDataSource;
  SymbolsSourceContext _defSymbolsSource;
  SignalHandlerContext _defSignalHandler;
  std::shared_ptr<PluginInstance<Commission> > _defCommissionPlugin;
  std::shared_ptr<PluginInstance<Slippage> > _defSlippagePlugin;

  chart::ChartManager* _chartManager;

  using RunnablePluginInstances = std::map<UniqueId, shared_ptr<PluginInstance<Runnable> > >;
  RunnablePluginInstances _runnablePluginInstances;
  using DataIteratorsMap = std::map<UniqueId, std::shared_ptr<DataInfoIterator> >;
  DataIteratorsMap _dataInfoIterators;

  std::vector<std::shared_ptr<Runnable> > _runnables;
  std::vector<std::shared_ptr<Commission> > _commissions;
  std::vector<std::shared_ptr<Slippage> > _slippages;

  bool _sessionEndedReceived;

  RuntimeStats* _rts;

  tradery::Session _session;

  Document& _document;
  //	SessionEventHandler* _sessionEventHandler;
  // if to repeat when reset
  RuntimeStatus _status;
  mutable std::mutex _mx;
  mutable std::mutex _mxStatusChange;
  size_t _sessionTradesCount;
  SessionParams* _params;
  OutputSink& _os;
  const UniqueId _shId;
  // the various session info instances must be held on to during the run, as
  // the various plug-ins may need them also, we are creating multiple instances
  // because each of them has a different symbols iterator
  std::vector<SessionInfoPtr> _si;

 private:
  SessionInfoPtr makeSessionInfo(DateTimeRangePtr range) {
    _si.push_back(std::make_shared< SessionInfoImpl>(_document.name(), _document.getSessionId(),
      _defDataSource.getDataSource(), range, _defSymbolsSource.makeIterator(), &_document.getRuntimeParams(), _rts, &_os));
    return _si.back();
  }

  void saveRawTradesCSVFile(const PositionsContainer& pos) const {
    const std::string file(getConfig().rawTradesCSVFile());
    if (!file.empty()) {
      LOG(log_debug, getConfig().getSessionId(), "Creating trades csv file: ", file);
      std::ofstream tradesCSVFile(file.c_str());

      if (!tradesCSVFile) {
        LOG(log_error, getConfig().getSessionId(), "error - can't open the trades CSV file for writing");
      }
      else {
        PositionsContainerToCSV toCSV(pos, tradesCSVFile);
      }
    }
  }


  // clears the vector that contains all the session info objects
  void clearSessionInfo() {
    _si.clear();
    _sessionEndedReceived = false;
  }

  void setStatusRunning() { setStatus(RUNNING); }

  void setStatusCanceling() { setStatus(CANCELING); }

  void setStatusReady() { setStatus(READY); }

  void setStatus(RuntimeStatus status) {
    LOG(log_debug, _document.getSessionId().str(), "setting status to ", ToString(_status));
    _status = status;
  }

  void notifySessionStarted(DateTimeRangePtr range) {
    LOG(log_info, getSessionId().str(), "begin");
    // clear all session infos
    clearSessionInfo();
    // create new session info objects for all plug-ins
    // the session infos are stored in a vector that is cleared every time a new
    // session starts this way each plug-in has their own instance, but they
    // don't need to manage the lifetime of the object
    _defSignalHandler.sessionStarted(*makeSessionInfo(range));
    _defDataSource.sessionStarted(*makeSessionInfo(range));
    _defSymbolsSource.sessionStarted(*makeSessionInfo(range));

    for (auto runnable : _runnables) {
      runnable->sessionStarted(*makeSessionInfo(range));
    }

    for (auto commission : _commissions) {
      commission->sessionStarted(*makeSessionInfo(range));
    }

    for (auto slippage : _slippages) {
      slippage->sessionStarted(*makeSessionInfo(range));
    }

    if (_document.getRuntimeParams().chartsEnabled()) _chartManager->init(_rts);
    LOG(log_info, getSessionId().str(), "end");
  }

  void notifySessionEnded() {
    LOG(log_info, getSessionId().str(), "begin");
    _sessionEndedReceived = true;

    // we have to serialize the charts here, because they depend on the
    // individual position containers being still valid, the next step
    // (reorganizePositions) will move all positions to the first collection,
    // thus emptying all the others move all positions generated by all systems
    // to the positions collection at the front of the vector containing all the
    // positions collections
    PositionsContainer& pc(*_params->populateAllPositions());

    // pc contains all raw positions, before position sizing.
    //TODO normally saving the raw trades should happen after the
    // session has ended, in runsystem, but because the positions
    // will be modified before that in order to perform position sizing
    // we need to do it now, before the position sizing
    // Another alternative would be to copy the raw positions
    // and use the copy later to save the trades, but for now
    // we'll just do the quick and dirty file save right here.
    saveRawTradesCSVFile(pc);

    _defSignalHandler.sessionEnded(pc);
    _defDataSource.sessionEnded(pc);
    _defSymbolsSource.sessionEnded(pc);

    for (auto runnable : _runnables) {
      runnable->sessionEnded(pc);
    }

    for (auto commission : _commissions) {
      commission->sessionEnded(pc);
    }

    for (auto slippage : _slippages) {
      slippage->sessionEnded(pc);
    }

    if (_chartManager != 0) {
      _chartManager->serialize();
    }

    LOG(log_info, getSessionId().str(), "end");
  }

  void notifySessionCanceled() {
    LOG(log_info, getSessionId().str(), "begin");
    _defSignalHandler.sessionCanceled();
    _defDataSource.sessionCanceled();
    _defSymbolsSource.sessionCanceled();

    for (auto runnable : _runnables) {
      runnable->sessionCanceled();
    }

    for (auto commission : _commissions) {
      commission->sessionCanceled();
    }

    for (auto slippage : _slippages) {
      slippage->sessionCanceled();
    }

    LOG(log_info, getSessionId().str(), "end");
  }

  void notifyRunStarted() {
    LOG(log_info, getSessionId().str(), "begin");
    _defSignalHandler.runStarted();
    _defDataSource.runStarted();
    _defSymbolsSource.runStarted();

    for (auto runnable : _runnables) {
      runnable->runStarted();
    }

    for (auto commission : _commissions) {
      commission->runStarted();
    }

    for (auto slippage : _slippages) {
      slippage->runStarted();
    }

    LOG(log_info, getSessionId().str(), "end");
  }

  void notifyRunCanceled() {
    LOG(log_info, getSessionId().str(), "begin");
    _defSignalHandler.runCanceled();
    _defDataSource.runCanceled();
    _defSymbolsSource.runCanceled();

    for (auto runnable : _runnables) {
      runnable->runCanceled();
    }

    for (auto commission : _commissions) {
      commission->runCanceled();
    }

    for (auto slippage : _slippages) {
      slippage->runCanceled();
    }

    LOG(log_info, getSessionId().str(), "end");
  }

  void notifyRunEnded() {
    LOG(log_info, getSessionId().str(), "begin");
    _defSignalHandler.runEnded();
    _defDataSource.runEnded();
    _defSymbolsSource.runEnded();

    for (auto runnable : _runnables) {
      runnable->runEnded();
    }

    for (auto commission : _commissions) {
      commission->runEnded();
    }

    for (auto slippage : _slippages) {
      slippage->runEnded();
    }

    LOG(log_info, getSessionId().str(), "end");
  }

 public:
  TASession(Document& document, SignalHandler* signals, ErrorEventSink* errorSink, RunnableRunInfoHandler* statusReceiver, RuntimeStats* rts, OutputSink& os)
      : _document(document),
        _session(this),
        _status(READY),
        _sessionTradesCount(0),
        _os(os),
        _sessionEndedReceived(false),
        _shId(signals->id()),
        _defDataSource(getGlobalPluginTree()),
        _chartManager(document.chartManager()),
        _rts(rts),
        _defSymbolsSource(getGlobalPluginTree()),
        _defSignalHandler(getGlobalPluginTree()) {
    _defSignalHandler.addSignalHandler(signals);
    TAErrorSink::setErrorSink(errorSink);
    RunsCounter::setRunnableStatusReceiver(statusReceiver);
  }

  ~TASession() { _defSignalHandler.removeSignalHandler(_shId); }

  template <typename T> void setConfig(std::shared_ptr<PluginInstance<T> > pi, std::shared_ptr<T> ds) {
    assert(false);
  }
  template <> void setConfig<DataSource>(std::shared_ptr<PluginInstance<DataSource> > pi, std::shared_ptr<DataSource> ds) {
    _defDataSource.set(pi, ds);
  }
  template <> void setConfig<SymbolsSource>(std::shared_ptr<PluginInstance<SymbolsSource> > pi, std::shared_ptr<SymbolsSource> ds) {
    _defSymbolsSource.set(pi, ds);
  }
  template <> void setConfig<SignalHandler>(std::shared_ptr<PluginInstance<SignalHandler> > pi, std::shared_ptr<SignalHandler> ds) {
    _defSignalHandler.set(pi, ds);
  }
  template <class T> void releaseConfig() {
    assert(false);
  }
  template <> void releaseConfig<DataSource>() {
    _defDataSource.release();
  }
  template <> void releaseConfig<SymbolsSource>() {
    _defSymbolsSource.release();
  }
  template <> void releaseConfig<SignalHandler>() {
    _defSignalHandler.release();
  }
  unsigned long runSignalCount() const {
    return _defSignalHandler.runSignalCount();
  }
  unsigned long sessionSignalCount() const {
    return _defSignalHandler.sessionCount();
  }
  bool sessionEndedReceived() const { return _sessionEndedReceived; }

  const UniqueId& getSessionId() const { return _document.getSessionId(); }

 private:
  void createRunnablePlugins() {
    LOG(log_info, getSessionId().str(), "start");
    try {
      for (const UniqueId* p = _document.getFirstRunnableId(); p != 0; p = _document.getNextRunnableId()) {
        LOG(log_debug, getSessionId().str(), "creating plugin for runnable id: ", p->str());
        assert(p != 0);
        const UniqueId* parent = _document.getSessionPluginTree().parent(*p);
        if (parent == 0) {
          LOG(log_error, getSessionId().str(), "could not find plugin for runnable id: ", p->str());
          throw TASessionException(tradery::format( "TASession::createRunnablePlugins - Could not find parent for runnable id: ", p->str()));
        }
        // todo: handle this case too
        assert(parent != 0);
        RunnablePluginInstances::iterator i = _runnablePluginInstances.find(*parent);
        std::shared_ptr<PluginInstance<Runnable> > rp;
        if (i == _runnablePluginInstances.end()) {
          rp = (_document.getSessionPluginTree().getPlugin<Runnable, Node::NodeType::RUNNABLE>(*parent));
          _runnablePluginInstances.insert( RunnablePluginInstances::value_type(*parent, rp));
        }
      }

      // for each runnable build its own commission object
      if (_document.hasDefaultCommission()) {
        const UniqueId* id = _document.getDefaultCommissionId();
        assert(id != 0);
        _defCommissionPlugin = getGlobalPluginTree().getPlugin<Commission, Node::NodeType::COMMISSION>(*id);
      }

      // for each runnable build its own commission object
      if (_document.hasDefaultSlippage()) {
        const UniqueId* id = _document.getDefaultSlippageId();
        assert(id != 0);
        _defSlippagePlugin = getGlobalPluginTree().getPlugin<Slippage, Node::NodeType::SLIPPAGE>(*id);
      }
    }
    catch (const IdNotFoundException& e) {
      LOG(log_error, getSessionId().str(), "IdNotFoundException (rethrowing): ", e.message());
      throw;
    }
    catch (...) {
      LOG(log_error, getSessionId().str(), "Uknown exception, re-throwing");
      throw;
    }
  }

  void createRunnable(const UniqueId* p) {
    assert(p != 0);
    LOG(log_info, getSessionId().str(), "creating runnable: ", p->str());
    const UniqueId* parent = _document.getSessionPluginTree().parent(*p);
    // todo: handle this case too
    assert(parent != 0);
    size_t k = _runnablePluginInstances.size();
    RunnablePluginInstances::iterator i = _runnablePluginInstances.find(*parent);
    std::shared_ptr<PluginInstance<Runnable> > rp;
    if (i != _runnablePluginInstances.end()) {
      rp = i->second;
    }
    else {
      assert(false);
    }

    std::shared_ptr<Runnable> runnable( (*rp)->get(*p, _document.getRunnablesStrings()));
    _runnables.push_back(runnable);

    std::shared_ptr< DataInfoIterator > dii = 0;
    DataIteratorsMap::iterator it = _dataInfoIterators.find(*p);

    // get the same data iterator for instances of the same system (based on
    // system id)
    if (it == _dataInfoIterators.end()) {
      dii = std::make_shared< SimpleDataInfoIterator >(_defDataSource.getDataSource(), _defSymbolsSource.makeIterator());
      _dataInfoIterators.insert(DataIteratorsMap::value_type(*p, dii));
    }
    else {
      dii = it->second;
    }

    // now create the commission object (if any)
    // each runnable gets its own instance of a commission object
    std::shared_ptr<Commission> commission;
    if (_defCommissionPlugin.get() != 0) {
      commission = ((*_defCommissionPlugin)->get(*_document.getDefaultCommissionId(), _document.defaultCommissionStrings()));
      _commissions.push_back(commission);
    }

    // now create the slippage object (if any)
    // each runnable gets its own instance of a slippage object
    std::shared_ptr<Slippage> slippage;
    if (_defSlippagePlugin.get() != 0) {
      slippage = ((*_defSlippagePlugin)->get(*_document.getDefaultSlippageId(),_document.defaultSlippageStrings()));
      _slippages.push_back(slippage);
    }

    _session.addRunnable(runnable.get(), _params->getPositionsVector(), /*error sink*/ this, dii, /*signal handler*/ &_defSignalHandler,
        /* runnable status receiver*/ this, slippage.get(), commission.get(), _chartManager, _document.getExplicitTrades(runnable->id()));
  }

  // this creates the runnables and their associated commissions, slippage etc
  void createRunnables() {
    size_t threads = _document.getRuntimeParams().getThreads();
    ThreadAlgorithm ta = _document.getRuntimeParams().getThreadAlgorithm();

    if (ta.oneSystemInMultipleThreds()) {
      if (_document.runnablesCount() >= threads) {
        for (const UniqueId* p = _document.getFirstRunnableId(); p != 0; p = _document.getNextRunnableId()) {
          createRunnable(p);
        }
      }
      else {
        const UniqueId* p = 0;
        for (unsigned long instances = 0; instances < threads; ++instances, p = _document.getNextRunnableId()) {
          if (p == 0) p = _document.getFirstRunnableId();
          createRunnable(p);
        }
      }
    }
    else {
      for (const UniqueId* p = _document.getFirstRunnableId(); p != 0; p = _document.getNextRunnableId()) {
        createRunnable(p);
      }
    }
  }

  void releaseRunnables() {
    // needs to be done before releasing the plugin, as their destructor is in
    // the plugin
    _runnables.clear();
    _commissions.clear();
    _slippages.clear();
    // clear the pointers to runnables from the scheduler
    _session.resetRunnables();
  }

  void releaseRunnablePlugins() {
    _runnablePluginInstances.clear();
    _defCommissionPlugin.reset();
    _defSlippagePlugin.reset();
  }

  void releasePlugins() {
    releaseRunnables();
    releaseRunnablePlugins();
    _defDataSource.release();
    _defSymbolsSource.release();
    if (_document.hasDefaultSignalHandler()) {
      _defSignalHandler.release();
    }
  }

  void resetCounters() {
    // reset the error counters
    TAErrorSink::reset();
    _defSignalHandler.reset();
    SessionRunTimer::reset();
    RunsCounter::reset();
    _sessionTradesCount = 0;
  }

 public:
  size_t runTradesCount() const { return _params->posCount(); }
  size_t sessionTradesCount() const {
    return _sessionTradesCount + _params->posCount();
  }

  // count: the number of times it will run before releasing the plugins
  // this mode it will wait for restart notification
  void start(PositionsVector& pos) {
    LOG(log_info, getSessionId().str(), "session starting");
    std::scoped_lock lock(_mx);
    _params = new SessionParams(pos);
    // start is not re-entrant
    if (_status != READY) {
      throw StartingActiveSessionException();
    }

    try {
      std::vector<std::string> errors;
      if (_document.hasDefaultDataSource() == 0) {
        errors.push_back("No default data source");
      }

      if (_document.hasDefaultSymbolsSource() == 0) {
        errors.push_back("No default symbols source");
      }

      if (_document.runnablesCount() == 0) {
        errors.push_back("No runnables to run");
      }

      if (errors.size() > 0) {
        std::string str;
        for (auto error : errors) {
          str += error + "\n";
        }

        throw TASessionException(str);
      }

      LOG(log_info, getSessionId().str(), "creating data source context");
      _defDataSource.create(*_document.getDefaultDataSourceId(), _document.defaultDataSourceStrings());
      _defSymbolsSource.create(*_document.getDefaultSymbolsSourceId(), _document.defaultSymbolsSourceStrings());
      if (_document.hasDefaultSignalHandler()) {
        _defSignalHandler.create(*_document.getDefaultSignalHandlerId(), _document.defaultSignalHandlerStrings());
      }
      LOG(log_info, getSessionId().str(), "creating runnable plugins");
      createRunnablePlugins();
      LOG(log_info, getSessionId().str(), "TASession::start - creating runnables");
      createRunnables();

      resetCounters();

      DateTimeRangePtr range = _document.getRuntimeParams().getRange();
      setStatusRunning();
      notifySessionStarted(range);
      _session.run(true, _document.getRuntimeParams().getThreads(), _document.getRuntimeParams().getThreadAlgorithm().processorAffinity(),
          range, _document.getRuntimeParams().startTradesDateTime());
      LOG(log_info, getSessionId().str(), "session ended");
    }
    catch (const PluginMethodException& e) {
      setStatusReady();
      throw TASessionException("Can't run session - plugin exception: "s +  e.message());
    }
    catch (const PluginInstanceException& e) {
      setStatusReady();
      throw TASessionException("Can't run session - plugin exception: "s + e.message());
    }
  }

  RuntimeStatus getStatus() const { return _status; }

  // from Running
  bool isRunning() const { return getStatus() != READY; }

  void cancel() {
    std::scoped_lock lock(_mx);
    std::unique_lock< std::mutex > statusChangeLock(_mxStatusChange);
    setStatusCanceling();
    // if running, cancel the current run (the release will happen on the
    // "ended" event)

    notifySessionCanceled();

    if (_session.isRunning()) {
      _session.cancelAsync();
    }
    else {
      // if not active run, release plugins
      notifySessionEnded();
      setStatusReady();
      statusChangeLock.unlock();
      releasePlugins();
    }
  }

  //****************
  // RunStatusEventHandler virtual methods
  // they do some local processing as well as are forwarded to the next receiver
  virtual void runStarted() {
    std::scoped_lock lock(_mx);
    std::unique_lock< std::mutex > statusChangeLock(_mxStatusChange);
    notifyRunStarted();
  }

  virtual void runCanceled() {
    std::scoped_lock lock(_mx);
    std::unique_lock< std::mutex > statusChangeLock(_mxStatusChange);
    setStatusCanceling();
    notifyRunCanceled();
  }
  virtual void runEnded() {
    std::scoped_lock lock(_mx);
    std::unique_lock< std::mutex > statusChangeLock(_mxStatusChange);
    // the session trade count is now updated
    SessionRunTimer::stopRun();
    notifyRunEnded();
    notifySessionEnded();
    releasePlugins();
    setStatusReady();
    statusChangeLock.unlock();
    releaseRunnables();
  }

  bool exportPositionsCSV(std::ostream& os) const {
    return _params->exportPositionsCSV(os);
  }

  void sendPositions(PositionHandler& pr, bool& cancel) {
    _params->sendPositions(pr, cancel);
  }

  unsigned __int64 defSymbolsCount() const {
    return _defSymbolsSource.symbolsCount();
  }
};
